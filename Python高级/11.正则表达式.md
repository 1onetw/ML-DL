# 正则表达式
### 介绍

是一种特殊的规则序列，也叫规则表达式（在代码中简写为re），是以一种表达式的方式对字符串进行匹配的语法规则。

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

##### 正则的优点

* 速度快，效率高，准确性高

##### 正则的缺点

* 新手上手难度较大

##### 正则语法表

默认情况下，正则表达式所匹配的字符**可以出现在字符串中任何位置**

- 特殊字符（另计）

    |    模式    |                             描述                             |
    | :--------: | :----------------------------------------------------------: |
    | **[A-Z]**  | [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 |
    | **[^ABC]** | 匹配除了 **[...]** 中字符的所有字符，例如 **[^aeiou]** 匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字母。 |
    | **[\s\S]** | 匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。 |

    

* 开头结尾

    | 模式  |                             描述                             |
    | :---: | :----------------------------------------------------------: |
    |   ^   | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。**^**，表示该模式只匹配那些以 **once** 开头的字符串。例如该模式与字符串 **"once upon a time"** 匹配，与 **"There once was a man from NewYork"** 不匹配。正如如 **^** 符号表示开头一样 |
    |   $   | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。，**$** 符号用来匹配那些以给定模式结尾的字符串"bucket$" |
    | ^...$ | 精确匹配，字符 **^** 和 **$** 同时使用时，表示精确匹配（字符串与模式一样）。例如：^bucket$只匹配字符串 **"bucket"**。如果一个模式不包括 **^** 和 **$**，那么它与任何包含该模式的字符串匹配。例如模式：once与字符串There once was a man from NewYork Who kept all of his cash in a bucket.是匹配的。 |

* 模糊匹配

| 模式 |                           描述                            |
| :--: | :-------------------------------------------------------: |
|  .   | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。 |
|  ？  | 匹配前面的子表达式零次或一次。要匹配 ? 字符，请使用 \?。  |
|  *   | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。  |
|  +   | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。  |
|  .*  |                  尝试匹配尽可能多的字符                   |
| .*？ |                  尝试匹配尽可能少的字符                   |
| a+b  |                        匹配a或者b                         |

* 括号

|       |                                                              |
| :---: | :----------------------------------------------------------: |
|  ( )  | 标记一个子表达式的开始和结束位置。子表达式也是一个组，可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
|  []   |                 匹配 **[...]** 中的所有字符                  |
|  {n}  | n 是一个非负整数。匹配前面子表达式确定的 **n** 次。例如，**o{2}** 不能匹配 **"Bob"** 中的 **o**，但是能匹配 **"food"** 中的两个 **o**。 |
| {n,}  | n 是一个非负整数。至少匹配前面的子表达式n 次。例如，**o{2,}** 不能匹配 **"Bob"** 中的 **o**，但能匹配 **"foooood"** 中的所有 **o**。**o{1,}** 等价于 **o+**。**o{0,}** 则等价于 **o\***。 |
| {n,m} | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。例如，**o{1,3}** 将匹配 **"fooooood"** 中的前三个 **o**。**o{0,1}** 等价于 **o?**。请注意在逗号和两个数之间不能有空格。 |

* 反斜杠



| 模式 |                             描述                             |
| :--: | :----------------------------------------------------------: |
|  \w  |                    匹配字母数字以及下划线                    |
|  \W  |                   匹配非字母数字以及下划线                   |
|  \s  |       匹配任何空白字符，包括空格、制表符、换页符等等。       |
|  \S  |                     匹配任何非空白字符。                     |
|  \d  |                       匹配任意数字0到9                       |
|  \D  |                        匹配任意非数字                        |
|  \A  |                      从字符串开始处匹配                      |
|  \Z  |                      从字符串结束处匹配                      |
|  \b  | 匹配一个单词边界，即字与空格间的位置。**\b** 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapteraster 中的字符串 ter\b，因为它出现在单词边界的前面： |
|  \B  | 非单词边界匹配。下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：\Bapt |
|  \f  |                       匹配一个换页符。                       |
|  \n  |                        匹配一个换行符                        |
|  \r  |                        匹配一个回车符                        |
|  \t  |                       匹配一个制表符。                       |
|  \v  |                      匹配一个垂直制表符                      |

- 组

|     模式     |                             描述                             |
| :----------: | :----------------------------------------------------------: |
| group（num） | 用来分组截获字符串，也可直接截获字符串，如将re.match的实例对象截获为字符串.（）用来分组，num为组号。group(1) 列出第一个括号匹配部分，group(2) 列出第二个括号匹配部分，group(3) 列出第三个括号匹配部分。group() 同group（0）就是匹配正则表达式整体结果。 |
|  groups（）  |            返回一个以所有组的字符串作为元素的元组            |

### re模块的使用



```python
'''
★★findall()匹配字符串中所有符合正则的内容，返回的是一个列表
参数：
pattern：匹配的正则表达式
string：需要匹配的字符串
flags：可选参数：re.I：忽略大小写
               re.M：多行模式=多行匹配，影响 ^ 和 $
               re.X：增加可读性，忽略空格和注释性内容
               re.S 使匹配 匹配包括换行在内的所有字符
            str = aabbab
                  aabbaa
                  bb
            print(re.findall(r'a.*?b',str,re.S))
           结果： ['aab', 'ab', 'aab', 'aa\n         b']
'''
import re
s = re.findall('m','mdsfieanmdcmsagfsdMcm',re.I)
print(s)
s1 = re.findall('\d+','sadfsda1654651,sadf454654')
print(s1)
★★# finditer()和findall类似，在字符串中找到符合要求的内容，但返回的是一个迭代器，迭代器里存储的每一个元素是re.match类的实例对象，打印对象返回的是__str__内置函数的返回值，返回了匹配的子字符串的下标和具体内容
s2 = re.finditer('\d+','fdsafhajskd135464,faseuihfas5641656123')
for i in s2:
    print(i.group())
s3 = re.finditer('\D+','dsajfoi654654,fdusiahf54544')
for k in s3:
    print(k.group())
★★# match（）函数只检测RE是不是在string的开始位置匹配， search()会扫描整个string查找匹配, 也就是说match（）只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none
# search()会扫描整个字符串并返回第一个成功的匹配
s4 = re.match('\d+','dsfa164565,afeaf61551')
s5 = re.match('\d+','454asdfsa,545sdafsa')
print(s4)
print(s5.group())#match()函数返回的不是迭代器，是re.match类的实例对象，打印对象返回的是__str__内置函数的返回值，返回了匹配的子字符串的下标和具体内容,需要使用.group()截获字符串
s6 = re.search('\d+','dksaf6546545,sdaf5416')
print(s6.group())
s7 = '123abc456'
r1 = re.search('\d+$',s7)
print(r1.group())
print(re.match('([0-9]*)([a-z]*)([0-9]*)',s7).group(0))
print(re.match('([0-9]*)([a-z]*)([0-9]*)',s7).group(1))
print(re.search('([0-9]*)([a-z]*)([0-9]*)',s7).group(2))
print(re.search('([0-9]*)([a-z]*)([0-9]*)',s7).group(3))
#上面这种分组截获数据，一般用search和match比较好，因为search和match截获到数据就返回，其他方法会看整体进行匹配,会对整体匹配完全。
★★# sub():替换，类似字符串中的replace方法
# 参数：
# pattern:匹配的模式，匹配出来的字符串
# repl：替换的字符串
# string:要被替换的字符串
# count；模糊匹配之后替换的最大次数，默认为0表示替换所有的匹配
# flags:可选参数
s8 = 'helloworld,hellotianjin'
su = re.sub('hello','nihao',s8)
print(su)

★★# compile()用于编译正则表达式，生成一个正则表达式对象，提供给match和search使用
# 参数：
# pattern：一个字符串形式的正则表达式
# flags；可选参数
obj = re.compile('\d{3}')
ret = obj.search('dsaf123sadf')
print(ret.group())
pattern = re.compile(r'\d+')
s9 = pattern.match('abc123def')
s10 = pattern.match('abc123def',3)#从下标为3的地方开始匹配，
print(s9)
print(s10.group())

import re
s1 = "abc'论昌周'def"
pattern1 = re.compile(r"abc'(?P<name>.*?)'def",re.S)
r = pattern1.finditer(s1)
for i in r:
    print(i.group('name'))
```



```python
1.匹配字符串中的内容  love
s1 = 'i love python'
2.匹配数字  所有的2
s = 'fddsa2dsaf2as2dfs2asd2f2dfg'
3.匹配x或y开头的单词，并且忽略大小写
s = 'mY name is xc,what is your name xuchao'
4.将字符串中所有的数字替换为 666
s = 'hello123456   hello78956'
5.贪婪匹配
6.非贪婪匹配
7.匹配所有的数字
8.匹配qq邮箱
```
