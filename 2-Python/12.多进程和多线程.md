# 多进程与多线程以及进程池与线程池：

## 多任务：

- 同时运行多个程序
- 可以将一个程序分解成多个若干相对独立的子任务
- 让多个子任务并发执行，从而缩短程序运行时间

## 并发和并行的区别：

- 并行：可以同一时刻互不干扰地做几件事(高速公路：所有车可以互不干扰地运行)

- 并发：同一时刻有很多事情要做(农村小路，只用一个车道，一个方向同一时刻只能通过一辆车，发生多辆汽车同时通过地情况就是并发)

- 并发的解决：

    食堂打饭经典例子

    1. 队列（缓存区，优先队列）

        缓存区：假设只有一个窗口，就只能排队打饭，排成的队列就是一个缓冲区，也叫缓存区，

        优先队列：假设女士优先，一个窗口有两队，一队男生，一队女生，只要有女生，女生就优先打饭，女生队列就是一个优先队列

    2. 争抢

        只开设一个窗口，没有秩序，谁能挤进去，就给谁打饭，打饭期间不能给其他人打饭，这就是锁机制。

        争抢可以让高并发--->并发，也是解决高并发的一种方式，但不好，因为可能有很多人很长时间打不到饭

    3. 预处理

        如果打饭慢的原因是因为现做，就可提前统计大多数人喜欢的菜，提前做好，保证供应，提高打饭效率，提高用户体验感

        预处理的思想是：加快用户获取数据的速度，常用来解决缓存区的数据也就是缓存。

    4. 并行

        多开设窗口，但会造成成本提高

    5. 提速

        提高单个窗口打饭速度

    6. 多地就近原则

        多开几个食堂，分流，进而解决高并发

## 进程与线程：

进程:(process)就是系统中执行的一个程序，是系统进行运算调度的最小单元

- 操作系统以进程为单位分配存储空间
- 每个进程都有自己的地址空间，数据栈以及其他用于追踪进程执行的辅助数据
- 操作系统管理所有的进程的执行，为它们分配合理的资源

线程：(Thread)是程序的执行流的最小单元，也被称为轻量级进程。线程是进程中执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。 

- 一个标准的线程是由线程id，当前指令指针，寄存器，堆栈组成：

    一个指向当前被执行指令的指令指针：IP寄存器，指向对应线程
    一个栈：对线程的一个快照存储，记录了所有线程的运行状态，包括调用堆栈，锁池情况等
    一个寄存器值的集合：定义了一部分描述正在执行线程的处理器状态的值
    一个私有的数据区：该线程私有的数据

    线程id：就是线程的编号

- 由于线程在进程之下，因此相对于进程而言，线程间的信息共享和通信更加容易

### 线程的状态：

1. 新建状态：线程对象已经创建，还没有在其上调用start()方法

2. 就绪状态：线程能够运行，但是等待被执行

3. 运行状态：线程正在被执行 

4. 阻塞状态：线程仍旧是可运行的，但没有条件运行，也就是线程等待外部事件发生而无法运行

5. 死亡状态：当线程的run()方法完成时就认为线程死去

    ​					这个线程对象也许是活得，但是，它已经不再是一个单独执行的线程

    ​					线程一旦死亡，就不能复生

    ​					如果在一个死去的线程上调用start()方法，就会报错

### Python中的多线程：

​		使用Thread模块可以实现多线程编程

#### Thread中的函数：

​			

|       描述       |                             含义                             |
| :--------------: | :----------------------------------------------------------: |
| current_thread() |                       返回当前线程对象                       |
|  main_thread()   |                        返回主线程对象                        |
|   get_ideent()   |                       返回当前线程的id                       |
|      run()       | 表示线程活动的方法(也就是线程具体的任务)，一般用于用类创建线程，类得继承基类Thread |
|     start()      |                         启动线程活动                         |
|      join()      |                主线程等待所有子线程终止再终止                |
|  active_count()  |                  返回active状态的线程的个数                  |

```python
# 单线程:
def func():
    for i in range(100):
        print('func',i)
if __name__ == '__main__':
    func()
    for i in range(100):
        print('main',i)
# 执行过程  程序启动--->  --->执行main---> 加载func() 调用func()--->func()执行完毕--->继续执行main中的内容
# 整个过程就是一条线往下跑，这就是单线程
```

#### 创建线程：

```python
语法：
Thread(target='',group='',name='',args='',kwargs='',daemon='')
target:线程调用的对象，就是目标函数
name:给线程起名字，如果没有设置name参数值，则会打印系统分配的Thread-1,Thread-2…这样的名称。
args:为目标函数传递位置参数，元组
kwargs:为目标函数传递关键字参数，字典
daemon:用来设置线程是否随主线程退出而退出
    # 1.函数创建线程(不需要传入参数):
from threading import Thread
def func():
    for i in range(1000):
        print('func',i)
t = Thread(target = func,name = 't1')
t.start()
for i in range(1000):
    print('main',i)
# 执行过程:  程序启动--->加载func()--->执行main--->创建子线程t--->启动子线程t--->执行func()|main剩余的内容

	# 1.函数创建线程(需要传入参数):
import time
import threading
def tes(x,y):
    for i in range(x,y):
        time.sleep(1)
        print(i)
t1 = threading.Thread(target=tes,name='t1',args=(1,10))
t2 = threading.Thread(target=tes,name='t2',args=(10,20))
t1.start()
t2.start()

# 2.类创建线程:
from threading import Thread
class Mythread(Thread):
    def run(self):
        for i in range(1000):
            print('子线程',i)
if __name__ == '__main__':
    t = Mythread()
    t.start()
    for i in range(1000):
        print('主线程',i)
  #类创建线程设置dameon属性
import threading
import time

class MyThread1(threading.Thread):
    def __init__(self,threadName,dae,arg1,arg2):
        super(MyThread1, self).__init__(name=threadName,daemon=dae)
        self.arg1=arg1
        self.arg2=arg2

    def run(self):
        for i in range(self.arg1,self.arg2):
            time.sleep(0.1)
            print(self.name, i)

class MyThread2(threading.Thread):
    def __init__(self,threadName,dae,arg1,arg2):
        super(MyThread2, self).__init__(name=threadName,daemon=dae)
        self.arg1=arg1
        self.arg2=arg2

    def run(self):
        for i in range(self.arg1,self.arg2):
            time.sleep(0.2)
            print(self.name, i)
            
 
if __name__=="__main__":
    t1 = MyThread1('t1',False,1,10) #t1设置daemon属性为Fasle。
    t2 = MyThread2('t2',True,101,110) #t1设置daemon属性为True。time.sleep(0.2)，t1先结束，主线程随着结束，此时t2未执行完，强制结束
    t1.start()
    t2.start()
    print(t1.daemon)
    print(t2.daemon)
    print("主线程完成了")

```

#### 主线程：

主线程是第一个启动的线程

父线程：如果启动A线程，A线程启动了一个B线程，A就是B的父线程

子线程：B就是A的子线程

创建线程时会有一个daemon属性，当daemon属性设置为False时，子线程不会随着主线程的结束而结束，主线程会等待所有的子线程结束再结束，当daemon属性设置为True时，子线程会随着主线程的结束而结束，主线程结束会导致其他的子线程强制结束

daemon属性必须在start()方法之前设置，否则就会报错，因为线程执行完后就是死亡状态，这样的设置没有意义

每个子线程都有daemon属性，可设置，也可不设置，不设置默认值为父线程的daemon

主线程的daemon属性值默认为False

如果子线程不设置daemon属性，就取父线程的daemon来设置它，子子线程继承子线程的daemon属性值

```python
# 对daemon属性进行设置，体会区别
import time
import threading
def tes():
    time.sleep(3)
    for i in range(10):
        print(i)
thread1 = threading.Thread(target=tes,daemon=False)
thread1.start()
print('主线程完成')
```

#### 阻塞线程:

**thread.join([timeout]) timeout 参数作为可选参数**，其功能是指定 thread 线程最多可以霸占 CPU 资源的时间（以秒为单位）。 如果省略，则默认直到 thread 执行结束（进入死亡状态）才释放 CPU 资源。

```python
语法：
join(timeout=None) 
timeout  用来指定调用者等待多久，如果没有设置，就一直等待被调用线程结束。
一个线程可以被join多次调用
import time
import threading
def tes1():
    time.sleep(5)
    for i in range(10):
        print(i)
thread1 = threading.Thread(target=tes1)
thread1.start()
thread1.join()
print('主线程完成')
# 主线程会等待0到9输出完之后再执行print
```

### 不带参多进程：

多进程使用资源换取效率，可以实现真正的并行

```python
# 单进程:
import time
def eat():
    for i in range(3):
        time.sleep(1)
        print('恰饭')
def drink():
    for i in range(3):
        time.sleep(1)
        print('喝汤')
eat()
drink()
# 先恰完所有饭，再喝完所有汤，由上至下
# 多进程:
import time
import multiprocessing
def eat():
    for i in range(3):
        time.sleep(1)
        print('恰饭')
def drink():
    for i in range(3):
        time.sleep(1)
        print('喝汤')
if __name__ == '__main__':
    eat_process = multiprocessing.Process(target=eat)
    drink_process = multiprocessing.Process(target=drink)
    eat_process.start()
    drink_process.start()
```

### 带参多进程：

使用args和kwargs

```python
import time
import multiprocessing
def eat(num,name):
    for i in range(num):
        time.sleep(1)
        print(name+'吃一口')
def drink(num,name):
    for i in range(num):
        time.sleep(1)
        print(name+'喝一口')
eat_process = multiprocessing.Process(target=eat,args=(3,'论昌周'))
drink_process = multiprocessing.Process(target=drink,kwargs={'num':4,'name':'论昌周'})
if __name__ == '__main__':
    eat_process.start()
    drink_process.start()
```

### 进程编号id：

需要导入os模块

获取进程编号的两种方法

```python
os.getpid 获取当前进程的编号
os.getppid 获取当前进程的父进程的编号

import os
import time
import multiprocessing
def eat():
    print('eat子进程的id是:',os.getpid())
    print('eat子进程的父进程的id是:',os.getppid())
    for i in range(5):
        time.sleep(1)
        print('恰饭',i)
def drink():
    print('drink子进程的id是:',os.getpid())
    print('drink子进程的父进程的id是:',os.getppid())
    for i in range(4):
        time.sleep(1)
        print('喝汤',i)
eat_process = multiprocessing.Process(target=eat)
drink_process = multiprocessing.Process(target=drink)
if __name__ == '__main__':
    eat_process.start()
    drink_process.start()
```

## 线程池和进程池：

​			线程池和进程池的基类是concurrent.futures模块中的executor，executor提供了两个子类，两个子类位于模块中，

​			一个是threadpoolexecutor(用来创建线程池)，另一个是processpoolexecutor(用来创建进程池)

### 			线程池：

线程池原理：创建一个池子，存放固定数量的线程，然后把我们要执行的任务提交到线程池，由线程池来分配哪一个线程来做哪一个任务

```python
pool(池子)常用方法：
terminate():terminate() 函数 是用来杀死子进程的；
shutdown():等待所有任务完成，并且把进程（线程）池关闭
close():关闭进程池（pool），使其不在接受新的任务，close()该函数执行后，会等待所有任务执行完成后，销毁每一个线程
join():主线程或主进程等待子线程或子进程执行完毕再结束
submit(func,'参数')：用于提交任务
通过使用 done() 方法判断该任务是否结束。上面的例子可以看出，提交任务后立即判断任务状态，显示四个任务都未完成。在延时2.5后，task1 和 task2 执行完毕，task3 仍在执行中。
使用 result() 方法可以获取任务的返回值。
```

```python
import time
from concurrent.futures import ThreadPoolExecutor
def tes1(max):
    time.sleep(2)
    print(max)
# 创建一个包含两条线程的线程池
pool = ThreadPoolExecutor(max_workers=2)
# 向线程提交任务和实参
pool.submit(tes1,'hello')
pool.submit(tes1,'world')
# 关闭线程池
pool.shutdown()

# 使用上下文管理协议，程序可以使用with语句来管理线程池，这样可以避免手动关闭线程池
import time
from concurrent.futures import ThreadPoolExecutor
def tes1(max):
    time.sleep(2)
    print(max)
with ThreadPoolExecutor(max_workers=2) as pool:
    pool.submit(tes1, 'hello')
    pool.submit(tes1,'world')
```

线程池的map方法:线程池的map()方法会为序列中的每一个元素启动一个线程，以并发的形式来执行函数，将数据返回保存到一个迭代器中:

```python
import time
from concurrent.futures import ThreadPoolExecutor
def tes1(max):
    time.sleep(2)
    print(max)
with ThreadPoolExecutor(max_workers=2) as pool:
    result = pool.map(tes1,('hello','world','nihao','shijie'))
    for r in result:
        print(r)
```

### 进程池：

既可以根据ProcessPoolExecutor创建，也可以根据Pool创建

apply()：同步执行(串行)
apply_async():异步执行(并行)

`join()`方法用于阻塞主进程，直到所有工作进程完成。

注意：在使用`join()`方法之前，必须先调用`close()`方法关闭进程池，否则会导致资源泄漏。

```python
# 阻塞状态  一次提交1个任务,提交10次，但后面的提交需要等第一个提交做完再做
# import time
# from  multiprocessing import Pool
# def tes1(max):
#     print(max)
#     time.sleep(3)
# if __name__ == '__main__':
#     pool = Pool(processes=10)
#     for i in range(100):
#         pool.apply(tes1, args=(i,))
#     print('完成')
#     pool.close()
#     pool.join()
# 非阻塞状态 一次提交1个任务，提交10次，后面的提交不需要等第一个提交做完任务在开始，他们10个进程一起做
# import time
# from  multiprocessing import Pool
# def tes1(max):
#     print(max)
#     time.sleep(3)
# if __name__ == '__main__':
#     pool = Pool(processes=10)
#     for i in range(100):
#         pool.apply_async(tes1, args=(i,))
#     print('完成')
#     pool.close()
#     pool.join()
```

进程池的map()方法，将序列内每一个对象作为单独的任务提交给进程池

```python
# 将序列中内每一个对象作为单独的任务提交给进程池
# 阻塞状态
# import time
# from  multiprocessing import Pool
# def tes1(max):
#     print(max)
#     time.sleep(3)
# if __name__ == '__main__':
#     pool = Pool(processes=2)
#     l1 = [1,2,3,4,5,6]
#     pool.map(tes1,l1)
#     print('完成')
#     pool.close()
#     pool.join()
# 非阻塞状态
# import time
# from  multiprocessing import Pool
# def tes1(max):
#     print(max)
#     time.sleep(3)
# if __name__ == '__main__':
#     pool = Pool(processes=2)
#     l1 = [1,2,3,4,5,6]
#     pool.map_async(tes1,l1)
#     print('完成')
#     pool.close()
#     pool.join()
# 其实没体现出来，因为是一整个序列去提交，不是for一个一个提交。
```

### 多进程与多线程的选择：

​	多进程适用于cpu密集型 ：机器学习

​	多线程适用于I/O密集型 ： 爬虫